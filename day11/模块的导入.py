# 模块导入的三种方式
# 1. import 模块名 [as 别名]
#    使用这种方式导入之后，使用时需要在对象之前加上模块名作为前缀，必须以“模块名.对象名”的形式进行访问。
#    如果模块名字很长的话，可以为导入的模块设置一个别名，然后使用“别名.对象名”的形式来使用其中的对象。
# 2. from 模块名 import 对象名[as 别名]
#     使用这种方式仅导入明确指定的对象，并且可以为导入的对象确定一个别名。这种导入方式可以减少查询次数，
#     提高访问的速度，同时也可以减少程序员需要输入的代码量，不需要使用模块名作为前缀
# 3. from 模块名 import *
#     这是上面用法的一种极端情况，可以一次导入模块中通过__all__变量指定的所有对象。
# 这种方式简单粗暴，写起来比较省事，可以直接使用模块中的所有对象而不需要再使用模块名作为前缀。
# 但一般并不推荐这样使用。一方面这样会降低代码的可读性，有时候很难区分自定义函数和从模块中导入的函数；
# 另一方面，这种导入对象的方式将会导致命名空间的混乱。如果多个模块中有同名的对象，
# 只有最后一个导入的模块中的对象是有效的，而之前导入的模块中的同名对象都将无法访问，不利于代码的理解和维护。

import time as myTime  #加了一个别名
print(myTime.ctime())
# print(time.ctime()) #调用模块中的函数了
import fileOpt
from time import ctime,time #部分导入
# from time import * # 全部导入4
print(ctime())
# from ...import 首次导入发生了3个步骤
# 1 以模块为准创造一个模块的名称空间
# 2 执行模块对应的文件了，将执行过程中产生的名字都丢到模块的名称空间
# 3 在当前执行文件的名称空间中拿到一个名字，该名字直接指向模块中的某一个名字,
# 意味着可以不用加任何的前缀而直接使用
# 优点：不用加前缀 代码更加简洁了 不用模块名.函数名 直接 函数名
# 缺点: 容易与当前执行文件中名称空间中的名字冲突

# import 到首次导入模块的时候 会发生如下3步操作
# 1 打开模块文件
# 2 执行模块对应的文件，将执行过程中产生的名字都丢到模块的名称空间
# 3 在程序中会有一个模块【可以取别名的】的名称指向模块的名称空间去

# 相同点和不同点
# 相同
# 都会执行模块对应的文件 并且呢 都会产生模块课的名称空间
# 两者在调用功能时呢，都需要转到定义时寻找作用域关系
# 不同点
# import 需要加前缀  from...import 不需要加前缀
